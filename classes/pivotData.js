// Generated by CoffeeScript 2.5.1
var hasProp = {}.hasOwnProperty;

import {
  aggregatorTemplates
} from "../aggregators/aggregators.js";

import {
  sortOperations
} from "../utilities/sorter.js";

export var PivotData = class PivotData {
  constructor(input, opts = {}) {
    var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
    this.arrSort = this.arrSort.bind(this);
    this.sortKeys = this.sortKeys.bind(this);
    this.getColKeys = this.getColKeys.bind(this);
    this.getRowKeys = this.getRowKeys.bind(this);
    this.getAggregator = this.getAggregator.bind(this);
    this.input = input;
    this.aggregator = (ref = opts.aggregator) != null ? ref : aggregatorTemplates.count()();
    this.aggregatorName = (ref1 = opts.aggregatorName) != null ? ref1 : "Count";
    this.colAttrs = (ref2 = opts.cols) != null ? ref2 : [];
    this.rowAttrs = (ref3 = opts.rows) != null ? ref3 : [];
    this.valAttrs = (ref4 = opts.vals) != null ? ref4 : [];
    this.sorters = (ref5 = opts.sorters) != null ? ref5 : {};
    this.rowOrder = (ref6 = opts.rowOrder) != null ? ref6 : "key_a_to_z";
    this.colOrder = (ref7 = opts.colOrder) != null ? ref7 : "key_a_to_z";
    this.derivedAttributes = (ref8 = opts.derivedAttributes) != null ? ref8 : {};
    this.filter = (ref9 = opts.filter) != null ? ref9 : (function() {
      return true;
    });
    this.tree = {};
    this.rowKeys = [];
    this.colKeys = [];
    this.rowTotals = {};
    this.colTotals = {};
    this.allTotal = this.aggregator(this, [], []);
    this.sorted = false;
    //iterate through input, accumulating data for cells
    PivotData.forEachRecord(this.input, this.derivedAttributes, (record) => {
      if (this.filter(record)) {
        return this.processRecord(record);
      }
    });
  }

  static forEachRecord(input, derivedAttributes, f) {
    var addRecord, compactRecord, i, j, k, l, len, record, ref, results, results1;
    if (Object.keys(derivedAttributes).length === 0 && derivedAttributes.constructor === Object) {
      addRecord = f;
    } else {
      addRecord = function(record) {
        var k, ref, v;
        for (k in derivedAttributes) {
          v = derivedAttributes[k];
          record[k] = (ref = v(record)) != null ? ref : record[k];
        }
        return f(record);
      };
    }
    if (typeof input === "function") {
      return input(addRecord);
    } else if (Array.isArray(input)) {
      if (Array.isArray(input[0])) {
        results = [];
        for (i in input) {
          if (!hasProp.call(input, i)) continue;
          compactRecord = input[i];
          if (!(i > 0)) {
            continue;
          }
          record = {};
          ref = input[0];
          for (j in ref) {
            if (!hasProp.call(ref, j)) continue;
            k = ref[j];
            record[k] = compactRecord[j];
          }
          results.push(addRecord(record)); //array of objects
        }
        return results;
      } else {
        results1 = [];
        for (l = 0, len = input.length; l < len; l++) {
          record = input[l];
          results1.push(addRecord(record));
        }
        return results1;
      }
    } else {
      throw new Error("unknown input format");
    }
  }

  arrSort(attrs) {
    var a, sortersArr;
    sortersArr = (function() {
      var l, len, results;
      results = [];
      for (l = 0, len = attrs.length; l < len; l++) {
        a = attrs[l];
        results.push(sortOperations.getSort(this.sorters, a));
      }
      return results;
    }).call(this);
    return function(a, b) {
      var comparison, i, sorter;
      for (i in sortersArr) {
        if (!hasProp.call(sortersArr, i)) continue;
        sorter = sortersArr[i];
        comparison = sorter(a[i], b[i]);
        if (comparison !== 0) {
          return comparison;
        }
      }
      return 0;
    };
  }

  sortKeys() {
    var v;
    if (!this.sorted) {
      this.sorted = true;
      v = (r, c) => {
        return this.getAggregator(r, c).value();
      };
      switch (this.rowOrder) {
        case "value_a_to_z":
          this.rowKeys.sort((a, b) => {
            return sortOperations.naturalSort(v(a, []), v(b, []));
          });
          break;
        case "value_z_to_a":
          this.rowKeys.sort((a, b) => {
            return -sortOperations.naturalSort(v(a, []), v(b, []));
          });
          break;
        default:
          this.rowKeys.sort(this.arrSort(this.rowAttrs));
      }
      switch (this.colOrder) {
        case "value_a_to_z":
          return this.colKeys.sort((a, b) => {
            return sortOperations.naturalSort(v([], a), v([], b));
          });
        case "value_z_to_a":
          return this.colKeys.sort((a, b) => {
            return -sortOperations.naturalSort(v([], a), v([], b));
          });
        default:
          return this.colKeys.sort(this.arrSort(this.colAttrs));
      }
    }
  }

  getColKeys() {
    this.sortKeys();
    return this.colKeys;
  }

  getRowKeys() {
    this.sortKeys();
    return this.rowKeys;
  }

  processRecord(record) {
    var colKey, flatColKey, flatRowKey, l, len, len1, m, ref, ref1, ref2, ref3, rowKey, x;
    colKey = [];
    rowKey = [];
    ref = this.colAttrs;
    for (l = 0, len = ref.length; l < len; l++) {
      x = ref[l];
      colKey.push((ref1 = record[x]) != null ? ref1 : "null");
    }
    ref2 = this.rowAttrs;
    for (m = 0, len1 = ref2.length; m < len1; m++) {
      x = ref2[m];
      rowKey.push((ref3 = record[x]) != null ? ref3 : "null");
    }
    flatRowKey = rowKey.join(String.fromCharCode(0));
    flatColKey = colKey.join(String.fromCharCode(0));
    this.allTotal.push(record);
    if (rowKey.length !== 0) {
      if (!this.rowTotals[flatRowKey]) {
        this.rowKeys.push(rowKey);
        this.rowTotals[flatRowKey] = this.aggregator(this, rowKey, []);
      }
      this.rowTotals[flatRowKey].push(record);
    }
    if (colKey.length !== 0) {
      if (!this.colTotals[flatColKey]) {
        this.colKeys.push(colKey);
        this.colTotals[flatColKey] = this.aggregator(this, [], colKey);
      }
      this.colTotals[flatColKey].push(record);
    }
    if (colKey.length !== 0 && rowKey.length !== 0) {
      if (!this.tree[flatRowKey]) {
        this.tree[flatRowKey] = {};
      }
      if (!this.tree[flatRowKey][flatColKey]) {
        this.tree[flatRowKey][flatColKey] = this.aggregator(this, rowKey, colKey);
      }
      return this.tree[flatRowKey][flatColKey].push(record);
    }
  }

  getAggregator(rowKey, colKey) {
    var agg, flatColKey, flatRowKey;
    flatRowKey = rowKey.join(String.fromCharCode(0));
    flatColKey = colKey.join(String.fromCharCode(0));
    if (rowKey.length === 0 && colKey.length === 0) {
      agg = this.allTotal;
    } else if (rowKey.length === 0) {
      agg = this.colTotals[flatColKey];
    } else if (colKey.length === 0) {
      agg = this.rowTotals[flatRowKey];
    } else {
      agg = this.tree[flatRowKey][flatColKey];
    }
    return agg != null ? agg : {
      value: (function() {
        return null;
      }),
      format: function() {
        return "";
      }
    };
  }

};
